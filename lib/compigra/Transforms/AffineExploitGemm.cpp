//===-  AffineExploitGemm.cpp - Expand the scope of gemm kernels-*- C++ -*-===//
//
// Compigra is under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// Implements the --affine-maximize-gemm pass, which detects and maximize the
// gemm kernels through loop transformations.
//
//===----------------------------------------------------------------------===//

#include "compigra/Transforms/AffineExploitGemm.h"
#include "mlir/Dialect/Affine/IR/AffineOps.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"

using namespace mlir;
using namespace compigra;

static Value getUpBoundValue(affine::AffineForOp forOp, OpBuilder &builder) {
  Value upBoundValue;

  auto outerUpBound = forOp.getUpperBound();
  if (outerUpBound.getMap().isSingleConstant()) {
    // create an arith::ConstantOp for the upper bound
    builder.setInsertionPointAfter(&*forOp.getRegion().getOps().begin());
    auto constOp = builder.create<arith::ConstantIntOp>(
        forOp.getLoc(), outerUpBound.getMap().getSingleConstantResult(), 32);
    upBoundValue = constOp.getResult();
  } else {
    upBoundValue = forOp.getUpperBound().getOperand(0);
  }
  return upBoundValue;
}

affine::AffineForOp verifyOuterLoop(affine::AffineForOp outerFor) {
  // check whether the outerFor has a single affine.for operation
  unsigned numOps = 0;
  affine::AffineForOp middleLoop;

  for (auto &op : outerFor.getBody()->getOperations()) {
    numOps++;
    if (isa<affine::AffineYieldOp>(op)) {
      break;
    }
    if (isa<affine::AffineForOp>(op)) {
      middleLoop = dyn_cast<affine::AffineForOp>(op);
    }
  }

  // Only one affine.for and an affine.yield operation is allowed
  if (numOps > 1 + 1) {
    return nullptr; // more than one affine.for operation
  }

  return middleLoop;
}

bool verifyStoreMap(AffineMap map, Operation::operand_range operands,
                    BlockArgument index1, // used in add
                    BlockArgument index2, // used in mul
                    Value stride) {       // used as symbol in mul

  // Check: exactly one result
  if (map.getNumResults() != 1)
    return false;

  // Check: exactly 2 dims and 1 symbol
  if (map.getNumDims() != 2 || map.getNumSymbols() != 1)
    return false;

  // Get the expression
  AffineExpr expr = map.getResult(0);

  // Match the expression: index1 + index2 * symbol(stride)
  auto addExpr = expr.dyn_cast<AffineBinaryOpExpr>();
  if (!addExpr || addExpr.getKind() != AffineExprKind::Add)
    return false;

  AffineExpr lhs = addExpr.getLHS();
  auto addDim = lhs.dyn_cast<AffineDimExpr>();

  auto mulExpr = addExpr.getRHS().dyn_cast<AffineBinaryOpExpr>();

  if (!mulExpr || mulExpr.getKind() != AffineExprKind::Mul)
    return false;

  auto mulDim = mulExpr.getLHS().dyn_cast<AffineDimExpr>();
  auto symExpr = mulExpr.getRHS().dyn_cast<AffineSymbolExpr>();

  if (!mulDim || !symExpr || !addDim)
    return false;

  // Verify that the operands at dim positions match the inputs
  if (operands[addDim.getPosition()] != index1)
    return false;

  if (operands[mulDim.getPosition()] != index2)
    return false;

  // Verify that the symbol matches the stride
  auto symDim = operands[map.getNumDims() + symExpr.getPosition()];
  if (symDim != stride)
    return false;

  return true;
}

affine::AffineForOp verifyMiddleLoop(affine::AffineForOp middleFor,
                                     BlockArgument outerIter,
                                     affine::AffineStoreOp &storeOp,
                                     GemmVar &gemmOpr, OpBuilder &builder) {
  // check whether the middleFor has a single affine.for operation
  unsigned numOps = 0;
  affine::AffineForOp innerLoop;
  Value innerLoopYield;
  auto middleIter = middleFor.getBody()->getArgument(0);
  auto middleUpBound = getUpBoundValue(middleFor, builder);
  gemmOpr.middleBound = middleUpBound;

  for (auto &op : middleFor.getBody()->getOperations()) {
    if (isa<affine::AffineYieldOp>(op)) {
      break;
    }
    // the inner most loop should be the first operation
    if (numOps == 0 && isa<affine::AffineForOp>(op)) {
      innerLoop = dyn_cast<affine::AffineForOp>(op);
      // check whether the innerLoop yield result
      if (innerLoop.getNumResults() == 1)
        innerLoopYield = innerLoop.getResult(0);
      else {
        llvm::errs() << "inner loop has no yield result\n";
        return nullptr; // no yield result
      }
    }
    // the store operation should satisfy the condition
    if (numOps == 1 && isa<affine::AffineStoreOp>(op)) {
      // check whether the store operation is inside the inner loop
      auto storeOp = dyn_cast<affine::AffineStoreOp>(op);
      // get value of the store operation and verify it equals to the inner
      // loop's result
      auto storeOpValue = storeOp.getValue();
      if (storeOpValue != innerLoopYield) {
        llvm::errs() << "inner loop yield value does not match\n";
        return nullptr;
      }
      // get the memref operand of the store operation
      auto storeOpMemRef = storeOp.getMemRefType();
      gemmOpr.memRefRes = storeOp.getMemRef();
      // verify this is 1D memref
      if (storeOpMemRef.getRank() != 1) {
        llvm::errs() << storeOpMemRef.getRank() << "~= 1\n";
        return nullptr;
      }
      // get the indices operand of the store operation
      auto storeMap = storeOp.getAffineMap();
      auto operands = storeOp.getMapOperands();
      if (!verifyStoreMap(storeMap, operands, middleIter, outerIter,
                          middleUpBound)) {
        llvm::errs() << "store operation does not match\n";
        return nullptr;
      }
      // llvm::errs() << "storeOpIdx: ";
      // for (auto idx : storeOpIdx) {
      //   llvm::errs() << idx << "\n";
      // }
      // llvm::errs() << "\n";
    }
    numOps++;
  }

  if (numOps > 2 + 1) {
    llvm::errs() << "more than one affine.for operation\n";
    return nullptr;
  }

  return innerLoop;
}

bool verifyInnerLoop(affine::AffineForOp innerLoop, BlockArgument outerIter,
                     BlockArgument middleIter, GemmVar &gemmOpr) {
  // check whether the innerLoop has a single affine.for operation
  unsigned numOps = 0;
  auto innerUpBound = innerLoop.getUpperBound().getOperand(0);
  gemmOpr.innerBound = innerUpBound;
  for (auto [ind, op] : llvm::enumerate(innerLoop.getBody()->getOperations())) {
    if (isa<affine::AffineYieldOp>(op)) {
      break;
    }
    if (ind == 0 && isa<affine::AffineLoadOp>(op)) {
      auto loadOp = dyn_cast<affine::AffineLoadOp>(op);
      // get the memref operand of the load operation
      auto loadOpMemRef = loadOp.getMemRefType();
      gemmOpr.memRef1 = loadOp.getMemRef();
      // verify this is 1D memref
      if (loadOpMemRef.getRank() != 1) {
        llvm::errs() << loadOpMemRef.getRank() << "~= 1\n";
        return false;
      }
    }
    if (ind == 1 && isa<affine::AffineLoadOp>(op)) {
      auto loadOp = dyn_cast<affine::AffineLoadOp>(op);
      // get the memref operand of the load operation
      auto loadOpMemRef = loadOp.getMemRefType();
      gemmOpr.memRef2 = loadOp.getMemRef();
      // verify this is 1D memref
      if (loadOpMemRef.getRank() != 1) {
        llvm::errs() << loadOpMemRef.getRank() << "~= 1\n";
        return false;
      }
    }
    numOps++;
  }
  return true;
}

bool verifyGemmRegion(affine::AffineForOp outerFor, OpBuilder &builder,
                      GemmVar &gemmOpr) {
  // check whether the affine.for region matches the expected pattern
  auto outerBlk = outerFor.getBody();
  gemmOpr.outerBound = getUpBoundValue(outerFor, builder);
  // check whether middleBlk has a single affine.for operation
  auto middleLoop = verifyOuterLoop(outerFor);
  if (!middleLoop)
    return false;

  // auto innerLoop = getSingleAffineForOp(middleLoop.getBody());
  affine::AffineStoreOp storeOp;
  auto innerLoop = verifyMiddleLoop(middleLoop, outerBlk->getArgument(0),
                                    storeOp, gemmOpr, builder);
  if (!innerLoop)
    return false;

  // check whether the innerLoop matches the expected gemm pattern
  auto innerBlk = innerLoop.getBody();
  auto innerUpBound = getUpBoundValue(innerLoop, builder);
  gemmOpr.innerBound = innerUpBound;

  if (!verifyInnerLoop(innerLoop, outerBlk->getArgument(0),
                       middleLoop.getBody()->getArgument(0), gemmOpr)) {
    llvm::errs() << "inner loop does not match\n";
    return false;
  }

  return true;
}

struct AffineMaximizeGemmPass
    : public compigra::impl::AffineMaximizeGemmBase<AffineMaximizeGemmPass> {
  explicit AffineMaximizeGemmPass() {}

  void runOnOperation() override {
    MLIRContext *ctx = &getContext();
    OpBuilder builder(ctx);

    // print the function
    affine::AffineForOp gemmOp;
    GemmVar gemmOpr;
    getOperation()->walk([&](Operation *op) {
      if (isa<affine::AffineForOp>(op))
        if (verifyGemmRegion(dyn_cast<affine::AffineForOp>(op), builder,
                             gemmOpr)) {
          gemmOp = dyn_cast<affine::AffineForOp>(op);
          llvm::errs() << "Found gemm region in function: " << *op << "\n";
          // replace gemmOp with cgra::gemmOp
          builder.setInsertionPoint(gemmOp);
          cgra::BlasGemmOp gemmOpNew = builder.create<cgra::BlasGemmOp>(
              gemmOp.getLoc(), gemmOpr.innerBound, gemmOpr.middleBound,
              gemmOpr.outerBound, gemmOpr.memRef1, gemmOpr.memRef2,
              gemmOpr.memRefRes);
          gemmOp.erase();
        }
    });

    // builder.setInsertionPoint(funcOp);
  }
};

namespace compigra {
std::unique_ptr<mlir::Pass> createAffineMaximizeGemm() {
  return std::make_unique<AffineMaximizeGemmPass>();
};
} // namespace compigra
