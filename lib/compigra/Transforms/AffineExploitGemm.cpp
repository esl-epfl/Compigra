//===-  AffineExploitGemm.cpp - Expand the scope of gemm kernels-*- C++ -*-===//
//
// Compigra is under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// Implements the --affine-maximize-gemm pass, which detects and maximize the
// gemm kernels through loop transformations.
//
//===----------------------------------------------------------------------===//

#include "compigra/Transforms/AffineExploitGemm.h"
#include "compigra/CgraDialect.h"
#include "compigra/CgraOps.h"
#include "mlir/Dialect/Affine/IR/AffineOps.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"

using namespace mlir;
using namespace compigra;

affine::AffineForOp verifyOuterLoop(affine::AffineForOp outerFor) {
  // check whether the outerFor has a single affine.for operation
  unsigned numOps = 0;
  affine::AffineForOp middleLoop;

  for (auto &op : outerFor.getBody()->getOperations()) {
    numOps++;
    if (isa<affine::AffineYieldOp>(op)) {
      break;
    }
    if (isa<affine::AffineForOp>(op)) {
      middleLoop = dyn_cast<affine::AffineForOp>(op);
    }
  }

  // Only one affine.for and an affine.yield operation is allowed
  if (numOps > 1 + 1) {
    return nullptr; // more than one affine.for operation
  }

  return middleLoop;
}

bool verifyStoreMap(AffineMap map, Operation::operand_range operands,
                    BlockArgument index1, // used in add
                    BlockArgument index2, // used in mul
                    Value stride) {       // used as symbol in mul

  // Check: exactly one result
  if (map.getNumResults() != 1)
    return false;

  // Check: exactly 2 dims and 1 symbol
  if (map.getNumDims() != 2 || map.getNumSymbols() != 1)
    return false;

  // Get the expression
  AffineExpr expr = map.getResult(0);

  // Match the expression: index1 + index2 * symbol(stride)
  auto addExpr = expr.dyn_cast<AffineBinaryOpExpr>();
  if (!addExpr || addExpr.getKind() != AffineExprKind::Add)
    return false;

  AffineExpr lhs = addExpr.getLHS();
  auto addDim = lhs.dyn_cast<AffineDimExpr>();

  auto mulExpr = addExpr.getRHS().dyn_cast<AffineBinaryOpExpr>();

  if (!mulExpr || mulExpr.getKind() != AffineExprKind::Mul)
    return false;

  auto mulDim = mulExpr.getLHS().dyn_cast<AffineDimExpr>();
  auto symExpr = mulExpr.getRHS().dyn_cast<AffineSymbolExpr>();

  if (!mulDim || !symExpr || !addDim)
    return false;

  // Verify that the operands at dim positions match the inputs
  if (operands[addDim.getPosition()] != index1)
    return false;

  if (operands[mulDim.getPosition()] != index2)
    return false;

  // Verify that the symbol matches the stride
  auto symDim = operands[map.getNumDims() + symExpr.getPosition()];
  if (symDim != stride)
    return false;

  return true;
}

affine::AffineForOp verifyMiddleLoop(affine::AffineForOp middleFor,
                                     BlockArgument outerIter,
                                     affine::AffineStoreOp &storeOp) {
  // check whether the middleFor has a single affine.for operation
  unsigned numOps = 0;
  affine::AffineForOp innerLoop;
  Value innerLoopYield;
  auto middleIter = middleFor.getBody()->getArgument(0);
  auto middleUpBound = middleFor.getUpperBound().getOperand(0);

  for (auto &op : middleFor.getBody()->getOperations()) {
    if (isa<affine::AffineYieldOp>(op)) {
      break;
    }
    // the inner most loop should be the first operation
    if (numOps == 0 && isa<affine::AffineForOp>(op)) {
      innerLoop = dyn_cast<affine::AffineForOp>(op);
      // check whether the innerLoop yield result
      if (innerLoop.getNumResults() == 1)
        innerLoopYield = innerLoop.getResult(0);
      else {
        llvm::errs() << "inner loop has no yield result\n";
        return nullptr; // no yield result
      }
    }
    // the store operation should satisfy the condition
    if (numOps == 1 && isa<affine::AffineStoreOp>(op)) {
      // check whether the store operation is inside the inner loop
      auto storeOp = dyn_cast<affine::AffineStoreOp>(op);
      // get value of the store operation and verify it equals to the inner
      // loop's result
      auto storeOpValue = storeOp.getValue();
      if (storeOpValue != innerLoopYield) {
        llvm::errs() << "inner loop yield value does not match\n";
        return nullptr;
      }
      // get the memref operand of the store operation
      auto storeOpMemRef = storeOp.getMemRefType();
      // verify this is 1D memref
      if (storeOpMemRef.getRank() != 1) {
        llvm::errs() << storeOpMemRef.getRank() << "~= 1\n";
        return nullptr;
      }
      // get the indices operand of the store operation
      auto storeMap = storeOp.getAffineMap();
      auto operands = storeOp.getMapOperands();
      if (!verifyStoreMap(storeMap, operands, middleIter, outerIter,
                          middleUpBound)) {
        llvm::errs() << "store operation does not match\n";
        return nullptr;
      }
      // llvm::errs() << "storeOpIdx: ";
      // for (auto idx : storeOpIdx) {
      //   llvm::errs() << idx << "\n";
      // }
      // llvm::errs() << "\n";
    }
    numOps++;
  }

  if (numOps > 2 + 1) {
    llvm::errs() << "more than one affine.for operation\n";
    return nullptr;
  }

  return innerLoop;
}

bool verifyGemmRegion(affine::AffineForOp outerFor, OpBuilder &builder) {
  // check whether the affine.for region matches the expected pattern
  auto outerBlk = outerFor.getBody();

  // check whether middleBlk has a single affine.for operation
  auto middleLoop = verifyOuterLoop(outerFor);
  if (!middleLoop)
    return false;

  // auto innerLoop = getSingleAffineForOp(middleLoop.getBody());
  affine::AffineStoreOp storeOp;
  auto innerLoop =
      verifyMiddleLoop(middleLoop, outerBlk->getArgument(0), storeOp);
  if (!innerLoop)
    return false;

  // check whether the innerLoop matches the expected gemm pattern

  return true;
}

struct AffineMaximizeGemmPass
    : public compigra::impl::AffineMaximizeGemmBase<AffineMaximizeGemmPass> {
  explicit AffineMaximizeGemmPass() {}

  void runOnOperation() override {
    MLIRContext *ctx = &getContext();
    OpBuilder builder(ctx);

    // print the function
    func::FuncOp funcOp;
    getOperation()->walk([&](Operation *op) {
      if (isa<affine::AffineForOp>(op))
        if (verifyGemmRegion(dyn_cast<affine::AffineForOp>(op), builder)) {
          llvm::errs() << "Found gemm region in function: " << *op << "\n";
        } else {
          llvm::errs() << "\n";
        }
    });

    // builder.setInsertionPoint(funcOp);
  }
};

namespace compigra {
std::unique_ptr<mlir::Pass> createAffineMaximizeGemm() {
  return std::make_unique<AffineMaximizeGemmPass>();
}
} // namespace compigra
